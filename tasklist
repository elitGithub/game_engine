Here is a high-level task list to track your progress in making the engine more robust.

You are correct to keep systems like Inventory and Item databases in your *game-specific* code. The tasks below are purely *engine-level* features that will make your engine more powerful and reusable for any game you build with it.

### Engine Enhancement Task List

- [ ] **Implement a Save/Load System**
    * **Task:** Create a `SaveManager` class that handles serializing and deserializing the game's state.
    * **Explanation:** This is the most critical feature for a robust engine. Players expect to be able to save their progress. You've already laid the perfect foundation by defining a `PlayerSaveData` interface in your `types/index.ts` file. This new manager would live in the `Engine` and use `localStorage` to save and load JSON data that conforms to that interface.

- [ ] **Create a Centralized Audio Manager**
    * **Task:** Build an `AudioManager` class to handle all audio loading and playback.
    * **Explanation:** Sound and music are essential for immersion. A dedicated `AudioManager` class, added to your `Engine`, will allow you to easily play background music, trigger sound effects from `Action` executions or `Scene` changes, and control volume from one central place.

- [ ] **Refactor for a Centralized Input System**
    * **Task:** Make the `Engine` class the primary listener for all user input (keyboard and mouse clicks).
    * **Explanation:** Currently, input is handled in multiple places. The `Engine` has `handleInput(input: string)` for text choices, while the `SpriteRenderer` defines its own `onClick` handlers. A more robust design is to have the `Engine` capture all input events and pass them to the `GameStateManager`, which then passes them to the *active state*. The active state is then responsible for figuring out what that click or keypress means.