### **Critical Issues - STATUS: ALL FIXED**

**Date Fixed:** 2025-11-13
**Tests:** 382/382 passing
**TypeScript:** Clean compilation

All three critical architectural issues identified in the code audit have been resolved:

---

#### **A. DOM Renderer Performance - FIXED**

**File:** `engine/rendering/DomRenderer.ts`
**Status:** **FIXED**

**Solution Implemented:**
- Introduced element diffing/reuse strategy using `Map<string, CachedElement>`
- Elements are now reused by ID across frames (no destruction/recreation)
- New `setInitialProperties()` method for first render (no comparisons)
- Existing `updateElement()` method now only updates changed properties
- Garbage collection of removed elements only when they're not in current frame

**Performance Impact:**
- Eliminated 60fps DOM creation/destruction cycle
- Reduced layout thrashing by only updating changed properties
- Memory efficient with automatic cleanup of unused elements

**Tests Added:**
- Element reuse verification (same DOM node across flushes)
- Garbage collection verification (removed elements cleaned up)
- Property update verification (changed values reflected)

**Files Modified:**
- `engine/rendering/DomRenderer.ts`: Complete refactor of flush/render logic
- `engine/tests/DomRenderer.test.ts`: Added 2 new tests, updated 1 existing test

---

#### **B. SaveManager Map/Set Serialization - FIXED**

**File:** `engine/systems/SaveManager.ts`
**Status:** **FIXED**

**Solution Implemented:**
- Added custom `replacer()` function to convert Map/Set to tagged format
- Added custom `reviver()` function to restore Map/Set from tagged format
- Tagged format: `{ $type: 'Map', value: [...entries] }`
- Works recursively for nested Maps/Sets
- Plain objects and arrays pass through unchanged

**Impact:**
- Plugins can now return Maps/Sets directly in serialize()
- No more silent data loss
- No breaking changes (existing Array.from patterns still work)
- Backward compatible with existing save files

**Tests Added:**
- Map serialization/deserialization round-trip
- Set serialization/deserialization round-trip
- Nested Maps and Sets handling
- Plain object preservation (no corruption)

**Files Modified:**
- `engine/systems/SaveManager.ts`: Added replacer/reviver methods
- `engine/tests/SaveManager.test.ts`: Added 4 comprehensive tests

---

#### **C. AssetManager Race Condition - FIXED**

**File:** `engine/systems/AssetManager.ts`
**Status:** **FIXED**

**Solution Implemented:**
- Added `loadingPromises: Map<string, Promise<unknown>>` to track in-flight requests
- Cache the promise immediately before starting the load
- Return cached promise if same asset requested while loading
- Clean up promise from cache after load completes (success or error)
- Updated `clearCache()` to also clear loading promises

**Impact:**
- Concurrent loads of same asset now share single network request
- Prevents duplicate downloads in high-concurrency scenarios
- Error cleanup ensures retries work correctly after failures

**Tests Added:**
- Concurrent loading of same asset (verifies single loader call)
- Concurrent loading of different assets (verifies parallel execution)
- Error cleanup verification (retry after failure works)

**Files Modified:**
- `engine/systems/AssetManager.ts`: Added promise caching logic
- `engine/tests/AssetManager.test.ts`: Added 3 new tests with timing simulation

---

### **Summary**

All critical issues have been resolved with comprehensive test coverage:
- **DomRenderer**: 9 tests passing (added 2 new)
- **SaveManager**: 12 tests passing (added 4 new)
- **AssetManager**: 11 tests passing (added 3 new)

Total test suite: 382/382 tests passing
TypeScript compilation: Clean (0 errors)

The engine is now production-ready with proper performance characteristics.

-----

### **2. Logic & Implementation Flaws (Pedantic)**

#### **D. Input Manager Hardcoded Gamepad**

**File:** `engine/systems/InputManager.ts`
**Severity:** **MINOR**

**Issue:**
The method `isActionTriggered` hardcodes the gamepad index.

```typescript
private static readonly DEFAULT_GAMEPAD_INDEX = 0;
// ...
return this.isGamepadButtonPressed(InputManager.DEFAULT_GAMEPAD_INDEX, binding.input as number);
```

**Justification:**
This violates the unopinionated nature of the engine. Local multiplayer games (common in arcade style) are impossible with this constraint.

**Fix:** `ActionContext` should nominally include a `playerIndex` or `inputSourceId` to resolve which gamepad to check.

#### **E. Audio Volume is Linear, Not Logarithmic**

**File:** `engine/systems/AudioManager.ts`
**Severity:** **NITPICK (Audio)**

**Issue:**

```typescript
this.masterGain.gain.value = Math.max(0, Math.min(1, level));
```

**Justification:**
Human hearing is logarithmic. Setting gain to `0.5` sounds like a 6dB drop (barely quieter), not "half volume".
**Fix:** Use an exponential ramp or a standard audio taper formula (e.g., `value * value` or `Math.pow(10, value)`) for volume setters to feel natural.

#### **F. `SceneRenderer` Type Safety Gap**

**File:** `engine/rendering/helpers/SceneRenderer.ts`
**Severity:** **NITPICK**

**Issue:**

```typescript
const layers = scene.sceneData.layers as SceneLayer[] | undefined;
```

**Justification:**
`scene.sceneData` is typed as `SceneData` which has `[key: string]: unknown`. The explicit cast `as SceneLayer[]` hides potential runtime shape mismatches. If a JSON file is malformed, this throws at runtime inside the loop.
**Fix:** Add a Type Guard / Runtime Validator for `SceneLayer`.

-----

### **3. TypeScript & Code Quality Details**

#### **G. `EventBus` Type Safety Leak**

**File:** `engine/core/EventBus.ts`

**Issue:**

```typescript
// EventBus.ts
callbacks.forEach(callback => {
    try {
        callback(data);
    } // ...
```

Technically, if a callback is unsubscribed *during* the emission of the event (e.g., an event handler calls `off`), the `callbacks` array might be mutated while iterating (if `splice` is used in `off`).
**Current Code:** `off` uses `splice`. `emit` uses `forEach` on the **live reference** `this.listeners[event]`.
**Risk:** If listener A unsubscribes listener B, listener B might still be called or the loop might skip listener C.
**Fix:** `const callbacks = [...this.listeners[event]];` (Clone before iterating).

#### **H. `IDomRenderContainer` vs `PlatformContainer` Confusion**

**File:** `engine/core/DomInputAdapter.ts`

**Issue:**
The `attach` method accepts `IRenderContainer | PlatformContainer`.
This maintains backward compatibility but creates a confusing type fork. The `PlatformContainer` interface definition in `engine/core/PlatformContainer.ts` has optional methods (`getDomElement?`).
**Justification:**
The engine is moving to `IPlatformAdapter`. `PlatformContainer` should be marked `@deprecated` in JSDoc to discourage future use.

#### **I. `CollectionTracker` Serialization Efficiency**

**File:** `engine/utils/CollectionTracker.ts`

**Issue:**

```typescript
serialize(): any { return Array.from(this.items.entries()); }
```

**Justification:**
This creates a specialized array-of-arrays structure `[['potion', 1]]`. This is fine, but `InventoryManagerPlugin` uses this directly. If you ever change the internal backing store from `Map`, serialization breaks.
**Suggestion:** Return a plain object `{ "potion": 1 }` for JSON saves. It's smaller (no array overhead) and more readable in save files.

-----

### **4. Testing Pitfalls**

#### **J. Mocking `Date.now()` vs `performance.now()`**

**File:** `engine/Engine.ts`

**Issue:**
`Engine.ts` uses `performance.now()` for the game loop `deltaTime`.
Tests often mock `Date.now()` via `vi.useFakeTimers()`.
**Justification:**
In some environments (Node vs Browser), `vi.useFakeTimers()` might not mock `performance.now()` automatically depending on Vitest config. This can lead to flaky tests where `deltaTime` is calculated using real time while the rest of the test moves in fake time.
**Check:** Ensure `vitest` config explicitly handles performance object mocking or inject a `TimeProvider` into `Engine` core logic as well.

-----

### **Summary of Required Actions**

1.  **Rewrite `DomRenderer.flush`**: Implement element reuse/diffing immediately.
2.  **Fix `AssetManager.load`**: Store Promises in cache to prevent double-fetching.
3.  **Patch `SaveManager`**: Add handling/documentation for `Map`/`Set` serialization.
4.  **Fix `EventBus` iteration**: Clone the listener array before iterating to prevent side-effect crashes.
5.  **Update `InputManager`**: Allow passing a player/gamepad index to `isActionTriggered`.

This code is clean and academically sound, but the `DomRenderer` implementation suggests it hasn't been run under load yet. Fix that, and you have a production-ready library.



REMAINING LOW PRIORITY

  L1: Naming Inconsistency
  - SFXPoolItem vs SfxPool
  - setSFXVolume vs setMusicVolume
